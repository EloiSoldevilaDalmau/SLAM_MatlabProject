
torad=pi/180;

%state and measurement sizes:
pose_size = 3;
motion_size = 3;
lmk_size = 2;

%
n_poses_st = 3;
n_lmks_st = 4;
n_poses_f = 1;
n_motion_f = 2;
n_lmks_f = 8;

%contruim els factors
factor{1+0} = struct(....       %com que no hi ha index zero ha de ser l'1
    'type', 'pose',....
    'measurement', [0.0; 0.0; 0.0],...  
    'covariance', 1e-3*eye(3, 3), ....
    'index', 0); %POTSER HA DE SER 1!!!!

factor{1+1} = struct(...   %és el factor 1 en el grafic exemple ja que aqui a matlab no podem posar index zero
    'type', 'motion',...
    'measurement', [1.0; 0.0; -5*torad],...  %fem que el factor 2 sigui el moviment d'avançar 1m en x i roti 5 graus
    'covariance', diag([1e-2, 1e-2, (2*torad)^2]),...
    'index', [0,1]); %index dels estats que s'uneixen
                                         
factor{1+2} = struct(...
    'type','motion',...
    'measurement',[1.05; -0.25; -10*torad],...
    'covariance', diag([1e-2,1e-2,(5*torad)^2]),...
    'index',[1,2]);

factor{1+3} = struct(...
    'type', 'lmk',...
    'measurement', [1.2; 40*torad],... %al ser tipu lmk només necessitem 2 mesures
    'covariance', diag([1e-2, (10*pi/180)*2]),...
    'index', [0,3]);

factor{1+4} = struct(...
    'type', 'lmk',...
    'measurement', [0.65; 95*torad],... %al ser tipu lmk només necessitem 2 mesures
    'covariance', diag([1e-2, (5*pi/180)*2]),...
    'index', [1,3]);

factor{1+5} = struct(...
    'type', 'lmk',...
    'measurement', [1.5; 30*torad],... %al ser tipu lmk només necessitem 2 mesures
    'covariance', diag([1.3e-2, (10*pi/180)*2]),...
    'index', [1,4]);

factor{1+6} = struct(...
    'type', 'lmk',...
    'measurement', [1.6; -35*torad],... %al ser tipu lmk només necessitem 2 mesures
    'covariance', diag([1.4e-2, (15*pi/180)*2]),...
    'index', [0,5]);

factor{1+7} = struct(...
    'type', 'lmk',...
    'measurement', [0.9; -75*torad],... %al ser tipu lmk només necessitem 2 mesures
    'covariance', diag([1.4e-2, (10*pi/180)*2]),...
    'index', [1,5]);

factor{1+8} = struct(...
    'type', 'lmk',...
    'measurement', [2.8; -28*torad],... %al ser tipu lmk només necessitem 2 mesures
    'covariance', diag([4e-2, (7*pi/180)*2]),...
    'index', [0,6]);

factor{1+9} = struct(...
    'type', 'lmk',...
    'measurement', [1.8; -35*torad],... %al ser tipu lmk només necessitem 2 mesures
    'covariance', diag([2.5e-2, (10*pi/180)*2]),...
    'index', [1,6]);

factor{1+10} = struct(...
    'type', 'lmk',...
    'measurement', [0.7; -40*torad],... %al ser tipu lmk només necessitem 2 mesures
    'covariance', diag([2e-2, (10*pi/180)*2]),...
    'index', [2,6]);



%construim els estats
states{1+0} = struct(...
    'type', 'pose',...
    'range', [1; 2; 3],...
    'value', [0; 0; 0]);

states{1+1} = struct(...
    'type', 'pose',...
    'range', [4; 5; 6],...
    'value', [0; 0; 0]); %ja sobrescriurem aquesta posició dins el bucle

states{1+2} = struct(...
    'type', 'pose',...
    'range', [7; 8; 9],...
    'value', [0; 0; 0]);

states{1+3} = struct(...
    'type', 'lmk',...
    'range', [10; 11],...
    'value', [0.5; 0]);

states{1+4} = struct(...
    'type', 'lmk',...
    'range', [12; 13],...
    'value', [1; 0]);

states{1+5} = struct(...
    'type', 'lmk',...
    'range', [14; 15],...
    'value', [0.5; 0]);

states{1+6} = struct(...
    'type', 'lmk',...
    'range', [16; 17],...
    'value', [1;0]);
    



%
dx = ones (states{end}.range(end), 1);
eps = 1e-6;

while norm(dx) > eps
    
    [A,r] = buildproblem(states, factor);
    A;
    r;
    dx = solvelinearized(A, r);
    
    states = updatestates (states, dx);
    
    drawmap(states, factor);
    
end


%hem de treure print del COST i del STEP NORM per cada iteració (el cost ha
%d'anar baixant)
%l'step és dx (la distància del nou minim amb el previ)